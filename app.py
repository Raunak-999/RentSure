# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-UJ4Vt_P22mPNBVCSvRrKwQ-JbFECFio
"""

import subprocess

# Authenticate with Google Cloud (you'll need to follow the auth flow)
subprocess.run(["gcloud", "auth", "login"], check=True)

# Set the project
subprocess.run(["gcloud", "config", "set", "project", "rentsure-hackathon"], check=True)

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import pickle
import json
from flask import Flask, request, jsonify
import locale

# Set locale for currency formatting
locale.setlocale(locale.LC_ALL, '')

# Core recommendation system
class PropertyRecommender:
    def __init__(self, user_df, property_df, interactions_df):
        self.user_df = user_df
        self.property_df = property_df
        self.interactions_df = interactions_df

        # Prepare data for collaborative filtering
        self.prepare_data()

    def prepare_data(self):
        # Create user-property interaction matrix
        self.user_property_matrix = self.interactions_df.pivot_table(
            index='user_id',
            columns='property_id',
            values='interaction_type',
            fill_value=0
        )

        # Calculate user similarity matrix
        self.user_similarity = cosine_similarity(self.user_property_matrix)

        # Prepare property features for content-based filtering
        self.property_features = self.property_df[['rent', 'bedrooms', 'bathrooms', 'location', 'pet_friendly']]

        # Normalize property features
        self.property_features_normalized = (self.property_features - self.property_features.mean()) / self.property_features.std()

        # Calculate property similarity matrix
        self.property_similarity = cosine_similarity(self.property_features_normalized)

    def get_collaborative_recommendations(self, user_id, top_n=5):
        """Get recommendations based on similar users"""
        if user_id not in self.user_property_matrix.index:
            return []

        user_idx = self.user_property_matrix.index.get_loc(user_id)

        # Get similar users
        similar_users = self.user_similarity[user_idx].argsort()[::-1][1:11]  # Top 10 similar users

        # Get properties that similar users interacted with
        recommendations = {}
        for similar_user_idx in similar_users:
            similar_user_id = self.user_property_matrix.index[similar_user_idx]
            similar_user_interactions = self.interactions_df[self.interactions_df['user_id'] == similar_user_id]

            for _, interaction in similar_user_interactions.iterrows():
                property_id = interaction['property_id']
                # Check if this user has already interacted with this property
                if not self.interactions_df[(self.interactions_df['user_id'] == user_id) &
                                           (self.interactions_df['property_id'] == property_id)].empty:
                    continue

                if property_id not in recommendations:
                    recommendations[property_id] = 0

                # Weight by similarity and interaction type
                recommendations[property_id] += (self.user_similarity[user_idx][similar_user_idx] *
                                                interaction['interaction_type'])

        # Sort and return top N recommendations
        top_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:top_n]
        return [prop_id for prop_id, _ in top_recommendations]

    def get_content_based_recommendations(self, user_id, top_n=5):
        """Get recommendations based on user preferences and property features"""
        if user_id not in self.user_df['user_id'].values:
            return []

        user_prefs = self.user_df[self.user_df['user_id'] == user_id].iloc[0]

        # Already interacted properties
        interacted_properties = self.interactions_df[self.interactions_df['user_id'] == user_id]['property_id'].unique()

        # Filter properties based on user preferences
        budget_filter = self.property_df['rent'] <= user_prefs['budget'] * 1.1  # 10% tolerance
        bedrooms_filter = self.property_df['bedrooms'] >= user_prefs['bedrooms_preference']

        filtered_properties = self.property_df[budget_filter & bedrooms_filter]

        # Remove already interacted properties
        filtered_properties = filtered_properties[~filtered_properties['property_id'].isin(interacted_properties)]

        if filtered_properties.empty:
            return []

        # Calculate preference similarity
        user_pref_vector = np.array([
            user_prefs['budget'] / 80000,  # Normalize budget
            user_prefs['bedrooms_preference'] / 5,
            user_prefs['bathrooms_preference'] / 4,
            user_prefs['location_preference'] / 5,
            user_prefs['pet_friendly_preference']
        ]).reshape(1, -1)

        property_vectors = filtered_properties[['rent', 'bedrooms', 'bathrooms', 'location', 'pet_friendly']].values
        property_vectors[:, 0] = property_vectors[:, 0] / 80000  # Normalize rent
        property_vectors[:, 1] = property_vectors[:, 1] / 5  # Normalize bedrooms
        property_vectors[:, 2] = property_vectors[:, 2] / 4  # Normalize bathrooms
        property_vectors[:, 3] = property_vectors[:, 3] / 5  # Normalize location

        # Calculate similarity scores
        similarity_scores = cosine_similarity(user_pref_vector, property_vectors)[0]

        # Get top N recommendations
        top_indices = similarity_scores.argsort()[::-1][:top_n]
        return filtered_properties.iloc[top_indices]['property_id'].tolist()

    def get_hybrid_recommendations(self, user_id, top_n=5):
        """Combine collaborative and content-based recommendations"""
        collaborative_recs = self.get_collaborative_recommendations(user_id, top_n=top_n)
        content_based_recs = self.get_content_based_recommendations(user_id, top_n=top_n)

        # Combine recommendations with weights
        hybrid_recs = {}

        for i, prop_id in enumerate(collaborative_recs):
            if prop_id not in hybrid_recs:
                hybrid_recs[prop_id] = 0
            hybrid_recs[prop_id] += (top_n - i) * 0.6  # Collaborative weight

        for i, prop_id in enumerate(content_based_recs):
            if prop_id not in hybrid_recs:
                hybrid_recs[prop_id] = 0
            hybrid_recs[prop_id] += (top_n - i) * 0.4  # Content-based weight

        # Sort and return top N recommendations
        top_recommendations = sorted(hybrid_recs.items(), key=lambda x: x[1], reverse=True)[:top_n]
        return [prop_id for prop_id, _ in top_recommendations]

    def get_property_details(self, property_id):
        """Get property details for a given property ID"""
        prop_data = self.property_df[self.property_df['property_id'] == property_id]
        if not prop_data.empty:
            prop_dict = prop_data.iloc[0].to_dict()
            # Format the rent amount
            prop_dict['rent_formatted'] = locale.currency(prop_dict['rent'], grouping=True)
            return prop_dict
        return None

    def print_user_friendly_recommendations(self, user_id, top_n=5):
        """Print recommendations in a user-friendly format"""
        # Get user preferences
        user_prefs = self.user_df[self.user_df['user_id'] == user_id]

        if user_prefs.empty:
            print(f"User {user_id} not found.")
            return

        user_prefs = user_prefs.iloc[0]

        # Get recommendations
        recommendations = self.get_hybrid_recommendations(user_id, top_n)

        # Print header
        print("\n" + "="*60)
        print(f"TOP {top_n} PROPERTY RECOMMENDATIONS FOR USER {user_id}")
        print("="*60)

        # Print user preferences
        print("\nBASED ON YOUR PREFERENCES:")
        print(f"Budget: {locale.currency(user_prefs['budget'], grouping=True)}")
        print(f"Preferred Bedrooms: {user_prefs['bedrooms_preference']}")
        print(f"Preferred Bathrooms: {user_prefs['bathrooms_preference']}")
        print(f"Location Preference: {user_prefs['location_preference']} (on a scale of 1-5)")
        print(f"Pet Friendly: {'Yes' if user_prefs['pet_friendly_preference'] else 'No'}")

        # Print recommendations
        print("\nWE RECOMMEND THE FOLLOWING PROPERTIES:")
        print("-"*60)

        for i, prop_id in enumerate(recommendations):
            prop_details = self.get_property_details(prop_id)
            if prop_details:
                print(f"\nRECOMMENDATION #{i+1}: Property ID {prop_id}")
                print(f"Rent: {prop_details['rent_formatted']} per month")
                print(f"Bedrooms: {prop_details['bedrooms']}")
                print(f"Bathrooms: {prop_details['bathrooms']}")
                print(f"Location Rating: {prop_details['location']} (on a scale of 1-5)")
                print(f"Pet Friendly: {'Yes' if prop_details['pet_friendly'] else 'No'}")

                # Match percentage (simplified for demonstration)
                match_percentage = np.random.randint(75, 96)  # Random match between 75% and 95%
                print(f"Match to Your Preferences: {match_percentage}%")

                # Add a separator
                print("-"*60)

        print("\nEND OF RECOMMENDATIONS")

# Flask API function with improved output
def create_recommendation_api():
    app = Flask(__name__)

    @app.route('/api/get_recommendations', methods=['POST'])
    def get_recommendations():
        data = request.get_json()

        # Extract data from the request
        user_id = data.get('user_id')
        user_data = data.get('userData', [])
        property_data = data.get('propertyData', [])
        interaction_data = data.get('interactionData', [])
        count = data.get('count', 5)

        # Convert to DataFrames
        user_df = pd.DataFrame(user_data)
        property_df = pd.DataFrame(property_data)
        interactions_df = pd.DataFrame(interaction_data)

        # Create recommender
        recommender = PropertyRecommender(user_df, property_df, interactions_df)

        # Get recommendations
        recommendations = recommender.get_hybrid_recommendations(user_id, top_n=count)

        # Get property details
        property_details = []
        for prop_id in recommendations:
            prop_data = property_df[property_df['property_id'] == prop_id]
            if not prop_data.empty:
                prop_dict = prop_data.iloc[0].to_dict()
                # Format the rent amount
                prop_dict['rent_formatted'] = locale.currency(prop_dict['rent'], grouping=True)
                property_details.append(prop_dict)

        return jsonify({
            'user_id': user_id,
            'recommendations': property_details
        })

    return app

# Sample data generator for initial setup
def generate_sample_data(num_users=100, num_properties=50):
    np.random.seed(42)

    # Generate user preferences
    user_preferences = []
    for user_id in range(1, num_users + 1):
        budget = np.random.randint(15000, 80000)
        bedrooms = np.random.randint(1, 5)
        bathrooms = np.random.randint(1, 4)
        location_preference = np.random.randint(1, 6)
        pet_friendly = np.random.choice([0, 1])

        user_preferences.append({
            'user_id': user_id,
            'budget': budget,
            'bedrooms_preference': bedrooms,
            'bathrooms_preference': bathrooms,
            'location_preference': location_preference,
            'pet_friendly_preference': pet_friendly
        })

    # Generate property listings
    properties = []
    for property_id in range(1, num_properties + 1):
        rent = np.random.randint(15000, 80000)
        bedrooms = np.random.randint(1, 5)
        bathrooms = np.random.randint(1, 4)
        location = np.random.randint(1, 6)
        pet_friendly = np.random.choice([0, 1])

        properties.append({
            'property_id': property_id,
            'rent': rent,
            'bedrooms': bedrooms,
            'bathrooms': bathrooms,
            'location': location,
            'pet_friendly': pet_friendly
        })

    # Generate user-property interactions
    interactions = []
    for user_id in range(1, num_users + 1):
        num_interactions = np.random.randint(1, 11)
        viewed_properties = np.random.choice(range(1, num_properties + 1),
                                            size=num_interactions,
                                            replace=False)

        for property_id in viewed_properties:
            interaction_type = np.random.randint(1, 4)
            interactions.append({
                'user_id': user_id,
                'property_id': property_id,
                'interaction_type': interaction_type
            })

    return pd.DataFrame(user_preferences), pd.DataFrame(properties), pd.DataFrame(interactions)

# Main function to run tests
if __name__ == "__main__":
    # Test the recommendation system
    user_df, property_df, interactions_df = generate_sample_data()
    recommender = PropertyRecommender(user_df, property_df, interactions_df)

    # Test for a user with user-friendly output
    test_user_id = 5
    recommender.print_user_friendly_recommendations(test_user_id)

    # Create and run the Flask app
    app = create_recommendation_api()
    app.run(debug=True, port=5000)

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
import locale
from flask import Flask, request, jsonify

# Set locale for currency formatting
locale.setlocale(locale.LC_ALL, '')

# Core recommendation system
class PropertyRecommender:
    def __init__(self, user_df, property_df, interactions_df):
        self.user_df = user_df
        self.property_df = property_df
        self.interactions_df = interactions_df

        # Prepare data for collaborative filtering
        self.prepare_data()

    def prepare_data(self):
        # Create user-property interaction matrix
        self.user_property_matrix = self.interactions_df.pivot_table(
            index='user_id',
            columns='property_id',
            values='interaction_type',
            fill_value=0
        )

        # Calculate user similarity matrix
        self.user_similarity = cosine_similarity(self.user_property_matrix)

        # Prepare property features for content-based filtering
        self.property_features = self.property_df[['rent', 'bedrooms', 'bathrooms', 'location', 'pet_friendly']]

        # Normalize property features
        self.property_features_normalized = (self.property_features - self.property_features.mean()) / self.property_features.std()

        # Calculate property similarity matrix
        self.property_similarity = cosine_similarity(self.property_features_normalized)

    # [Include all other methods of PropertyRecommender here]
    def get_collaborative_recommendations(self, user_id, top_n=5):
        """Get recommendations based on similar users"""
        if user_id not in self.user_property_matrix.index:
            return []

        user_idx = self.user_property_matrix.index.get_loc(user_id)

        # Get similar users
        similar_users = self.user_similarity[user_idx].argsort()[::-1][1:11]  # Top 10 similar users

        # Get properties that similar users interacted with
        recommendations = {}
        for similar_user_idx in similar_users:
            similar_user_id = self.user_property_matrix.index[similar_user_idx]
            similar_user_interactions = self.interactions_df[self.interactions_df['user_id'] == similar_user_id]

            for _, interaction in similar_user_interactions.iterrows():
                property_id = interaction['property_id']
                # Check if this user has already interacted with this property
                if not self.interactions_df[(self.interactions_df['user_id'] == user_id) &
                                           (self.interactions_df['property_id'] == property_id)].empty:
                    continue

                if property_id not in recommendations:
                    recommendations[property_id] = 0

                # Weight by similarity and interaction type
                recommendations[property_id] += (self.user_similarity[user_idx][similar_user_idx] *
                                                interaction['interaction_type'])

        # Sort and return top N recommendations
        top_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:top_n]
        return [prop_id for prop_id, _ in top_recommendations]

    def get_content_based_recommendations(self, user_id, top_n=5):
        """Get recommendations based on user preferences and property features"""
        if user_id not in self.user_df['user_id'].values:
            return []

        user_prefs = self.user_df[self.user_df['user_id'] == user_id].iloc[0]

        # Already interacted properties
        interacted_properties = self.interactions_df[self.interactions_df['user_id'] == user_id]['property_id'].unique()

        # Filter properties based on user preferences
        budget_filter = self.property_df['rent'] <= user_prefs['budget'] * 1.1  # 10% tolerance
        bedrooms_filter = self.property_df['bedrooms'] >= user_prefs['bedrooms_preference']

        filtered_properties = self.property_df[budget_filter & bedrooms_filter]

        # Remove already interacted properties
        filtered_properties = filtered_properties[~filtered_properties['property_id'].isin(interacted_properties)]

        if filtered_properties.empty:
            return []

        # Calculate preference similarity
        user_pref_vector = np.array([
            user_prefs['budget'] / 80000,  # Normalize budget
            user_prefs['bedrooms_preference'] / 5,
            user_prefs['bathrooms_preference'] / 4,
            user_prefs['location_preference'] / 5,
            user_prefs['pet_friendly_preference']
        ]).reshape(1, -1)

        property_vectors = filtered_properties[['rent', 'bedrooms', 'bathrooms', 'location', 'pet_friendly']].values
        property_vectors[:, 0] = property_vectors[:, 0] / 80000  # Normalize rent
        property_vectors[:, 1] = property_vectors[:, 1] / 5  # Normalize bedrooms
        property_vectors[:, 2] = property_vectors[:, 2] / 4  # Normalize bathrooms
        property_vectors[:, 3] = property_vectors[:, 3] / 5  # Normalize location

        # Calculate similarity scores
        similarity_scores = cosine_similarity(user_pref_vector, property_vectors)[0]

        # Get top N recommendations
        top_indices = similarity_scores.argsort()[::-1][:top_n]
        return filtered_properties.iloc[top_indices]['property_id'].tolist()

    def get_hybrid_recommendations(self, user_id, top_n=5):
        """Combine collaborative and content-based recommendations"""
        collaborative_recs = self.get_collaborative_recommendations(user_id, top_n=top_n)
        content_based_recs = self.get_content_based_recommendations(user_id, top_n=top_n)

        # Combine recommendations with weights
        hybrid_recs = {}

        for i, prop_id in enumerate(collaborative_recs):
            if prop_id not in hybrid_recs:
                hybrid_recs[prop_id] = 0
            hybrid_recs[prop_id] += (top_n - i) * 0.6  # Collaborative weight

        for i, prop_id in enumerate(content_based_recs):
            if prop_id not in hybrid_recs:
                hybrid_recs[prop_id] = 0
            hybrid_recs[prop_id] += (top_n - i) * 0.4  # Content-based weight

        # Sort and return top N recommendations
        top_recommendations = sorted(hybrid_recs.items(), key=lambda x: x[1], reverse=True)[:top_n]
        return [prop_id for prop_id, _ in top_recommendations]

    def get_property_details(self, property_id):
        """Get property details for a given property ID"""
        prop_data = self.property_df[self.property_df['property_id'] == property_id]
        if not prop_data.empty:
            prop_dict = prop_data.iloc[0].to_dict()
            # Format the rent amount
            prop_dict['rent_formatted'] = locale.currency(prop_dict['rent'], grouping=True)
            return prop_dict
        return None

    def print_user_friendly_recommendations(self, user_id, top_n=5):
        """Print recommendations in a user-friendly format"""
        # Get user preferences
        user_prefs = self.user_df[self.user_df['user_id'] == user_id]

        if user_prefs.empty:
            print(f"User {user_id} not found.")
            return

        user_prefs = user_prefs.iloc[0]

        # Get recommendations
        recommendations = self.get_hybrid_recommendations(user_id, top_n)

        # Print header
        print("\n" + "="*60)
        print(f"TOP {top_n} PROPERTY RECOMMENDATIONS FOR USER {user_id}")
        print("="*60)

        # Print user preferences
        print("\nBASED ON YOUR PREFERENCES:")
        print(f"Budget: {locale.currency(user_prefs['budget'], grouping=True)}")
        print(f"Preferred Bedrooms: {user_prefs['bedrooms_preference']}")
        print(f"Preferred Bathrooms: {user_prefs['bathrooms_preference']}")
        print(f"Location Preference: {user_prefs['location_preference']} (on a scale of 1-5)")
        print(f"Pet Friendly: {'Yes' if user_prefs['pet_friendly_preference'] else 'No'}")

        # Print recommendations
        print("\nWE RECOMMEND THE FOLLOWING PROPERTIES:")
        print("-"*60)

        for i, prop_id in enumerate(recommendations):
            prop_details = self.get_property_details(prop_id)
            if prop_details:
                print(f"\nRECOMMENDATION #{i+1}: Property ID {prop_id}")
                print(f"Rent: {prop_details['rent_formatted']} per month")
                print(f"Bedrooms: {prop_details['bedrooms']}")
                print(f"Bathrooms: {prop_details['bathrooms']}")
                print(f"Location Rating: {prop_details['location']} (on a scale of 1-5)")
                print(f"Pet Friendly: {'Yes' if prop_details['pet_friendly'] else 'No'}")

                # Match percentage (simplified for demonstration)
                match_percentage = np.random.randint(75, 96)  # Random match between 75% and 95%
                print(f"Match to Your Preferences: {match_percentage}%")

                # Add a separator
                print("-"*60)

        print("\nEND OF RECOMMENDATIONS")


# Flask API function
def create_recommendation_api():
    app = Flask(__name__)

    @app.route('/api/get_recommendations', methods=['POST'])
    def get_recommendations():
        data = request.get_json()

        # Extract data from the request
        user_id = data.get('user_id')
        user_data = data.get('userData', [])
        property_data = data.get('propertyData', [])
        interaction_data = data.get('interactionData', [])
        count = data.get('count', 5)

        # Convert to DataFrames
        user_df = pd.DataFrame(user_data)
        property_df = pd.DataFrame(property_data)
        interactions_df = pd.DataFrame(interaction_data)

        # Create recommender
        recommender = PropertyRecommender(user_df, property_df, interactions_df)

        # Get recommendations
        recommendations = recommender.get_hybrid_recommendations(user_id, top_n=count)

        # Get property details
        property_details = []
        for prop_id in recommendations:
            prop_data = property_df[property_df['property_id'] == prop_id]
            if not prop_data.empty:
                prop_dict = prop_data.iloc[0].to_dict()
                # Convert numeric types to Python native types for JSON serialization
                for key, value in prop_dict.items():
                    if isinstance(value, np.integer):
                        prop_dict[key] = int(value)
                    elif isinstance(value, np.floating):
                        prop_dict[key] = float(value)
                property_details.append(prop_dict)

        return jsonify({
            'user_id': user_id,
            'recommendations': property_details
        })

    return app

# Sample data generator for initial setup
def generate_sample_data(num_users=100, num_properties=50):
    np.random.seed(42)

    # Generate user preferences
    user_preferences = []
    for user_id in range(1, num_users + 1):
        budget = np.random.randint(15000, 80000)
        bedrooms = np.random.randint(1, 5)
        bathrooms = np.random.randint(1, 4)
        location_preference = np.random.randint(1, 6)
        pet_friendly = np.random.choice([0, 1])

        user_preferences.append({
            'user_id': user_id,
            'budget': budget,
            'bedrooms_preference': bedrooms,
            'bathrooms_preference': bathrooms,
            'location_preference': location_preference,
            'pet_friendly_preference': pet_friendly
        })

    # Generate property listings
    properties = []
    for property_id in range(1, num_properties + 1):
        rent = np.random.randint(15000, 80000)
        bedrooms = np.random.randint(1, 5)
        bathrooms = np.random.randint(1, 4)
        location = np.random.randint(1, 6)
        pet_friendly = np.random.choice([0, 1])

        properties.append({
            'property_id': property_id,
            'rent': rent,
            'bedrooms': bedrooms,
            'bathrooms': bathrooms,
            'location': location,
            'pet_friendly': pet_friendly
        })

    # Generate user-property interactions
    interactions = []
    for user_id in range(1, num_users + 1):
        num_interactions = np.random.randint(1, 11)
        viewed_properties = np.random.choice(range(1, num_properties + 1),
                                            size=num_interactions,
                                            replace=False)

        for property_id in viewed_properties:
            interaction_type = np.random.randint(1, 4)
            interactions.append({
                'user_id': user_id,
                'property_id': property_id,
                'interaction_type': interaction_type
            })

    return pd.DataFrame(user_preferences), pd.DataFrame(properties), pd.DataFrame(interactions)

# Create the Flask application
app = create_recommendation_api()

# Main function to run tests
if __name__ == "__main__":
    # Test the recommendation system
    user_df, property_df, interactions_df = generate_sample_data()
    recommender = PropertyRecommender(user_df, property_df, interactions_df)

    # Test for a user with user-friendly output
    test_user_id = 5
    recommender.print_user_friendly_recommendations(test_user_id)

    # Run the Flask app
    app.run(debug=True, port=5000)